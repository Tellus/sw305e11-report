\section{Controller}
\label{controller}
This section will discuss the controller layer of the Giraf site, in particular the GirafController class as well as the interplay of JSON and the incomplete views that are output by certain controller actions. The discussion will center on the philosophy and inspirations behind the technical design of the controller, finally leading to the implementation that was completed as part of the this project period. The section will end with an overview an example usage of the three base scenarios envisioned for GirafController.

\subsection{Patterns}
As is noted by the MVC pattern, the controller receives user input and reacts to it in a manner fitting for the user's request. Where some designs make use of the observer pattern to relate any changes in the model to the view so anything displayed to the user is also updated, this project's implementation more closely follows the polling pattern. Changes in the view are thus reflected when the view refreshes upon request by the controller, not when data is updated in the model.

The method of input/output is highly inspired by several existing web-based MVC frameworks, most notably Ruby on Rails (implemented in the Ruby programming language) and CodeIgniter (made in PHP) - the specifics will be discussed in \vref{controller_design}.

\subsection{Base concept}
Ensuring that the security concerns voice by Birken \todo{Need an interview reference(s), specifying the need for secure data - Joe} would be addressed was a key factor when considering how to implement the input/output flow through the website. 
% Discuss, or at least reference, how webserver configurations are necessary to ensure proper security since we cannot force all connections to go through index.php or the few allowed directories without.

\subsubsection*{Security concerns}
The assets that need to be secure are universally defined as the user-generated content associated with users and children. In the specific context of this project, this is their personal details, Contactbook messages and the attached images. In the current design, all human-readable data (text) resides in the database, while binary data (images) are stored as-is on the file system. While information stored in the database is only accessible via intermediary scripts, files stored as-is on disk are made available externally by the webserver. This presents a significant vulnerability as no authorisation is required to access the images associated with Contactbook messages. There are several ways to remedy the issue:

\begin{description}
    \item[Temporary files] One approach involves copying inaccessible files to accessible locations on the web server with randomly generated names. Once the images have been loaded by the client they can be safely removed (images are transferred during page load and not used for the remainder of the page display). Disk usage can further be reduced by using linking features specific to operating systems (Linux systems' ln command or the junction points of Windows' junction points), eliminating redundant versions of identical files. This approach presents the same basic vulnerabilities as the current implementation (files are externally accessible), but to a much lesser degree (only files currently in use are exposed). However, this comes at the cost of file maintenance. Server-side scripts will need to remove the files when they are no longer required.
    \item[Direct image output] Another approach is to store files in a location that is inaccessible to external sources, and output the content of the files through the MVC framework directly to the client. The difference between transmitting a page of HTML or binary image data is discernible only by the actual data and the MIME type reported by the server during transmission. Using this approach will make it possible to access all resources through a single access point (for example, a controller that receives resource identifiers and outputs their contents if the request can be authorised), giving strict control over access. An added benefit is that the actual resource data can be stored in any location that is reachable by the server-side PHP code, be it file system, within databases or on remote servers. The only immediate downside is the added overhead of the script that needs to output the data (in contrast to regular file accessibility, in which only the web server is active in delivering data).
    \item[Authentication schemes] A third approach is to use one of the many authentication protocols supported by HTTP to restrict access to externally accessible resources. While this vastly simplifies the storage of resources on the server (to the level of the current implementation), it bears the need to implement support for the authentication protocol in the web pages and may require additional software on server and/or client.
\end{description}

Each approach has merit depending on the context, although the final level of security increases roughly from the first approach to the third. The second approach is both simple to implement (all of the required functionality exists in PHP) and exhibits a level of access control that is only limited by the robustness of the code. Injection attacks, cross-site scripting and the like are still concerns.

The seeds of the resource access restrictions already exist in the framework. The site is intended to be used by clients exclusively through the execution of the base index.php script as well as access to three key directories: css (for stylesheets), js (for javascript files) and img (for all images). A default web server configuration will typically allow access to all resources, requiring additional setup when installing the software on a new server. See the appendix (\vref{appendix_server_conf}) for an example configuration used by the project group's installation. It restricts access to all other resources than the four named, redirecting all unrecognized requests directly to the index.php file. This adds the benefit of making a cleaner, more easily read URL format.

\subsubsection*{File structure}
All controllers reside in the \emph{/controllers} subdirectory of the web site document root. Furthermore, given the convention of placing GIRAF application-specific data in \emph{/apps} subdirectories, any administration controllers offered by uploaded GIRAF applications are stored in such a directory.

It is the intention that all controllers callable directly by the user reside in the root, while all GIRAF application controllers (referenced as sub-controllers) must be accessed by primary controllers. A special controller for this purpose (the module controller) exists to allow restricted access to them externally.

\subsection{Controller design}
\label{controller_design}
As mentioned the Giraf MVC design is highly inspired by that of other web-based MVC frameworks, in which each controller is represented by a subclass of a base controller class. Barring a few special name cases, each public method of the class is considered an action that can be invoked directly by a client.
In the case of the GIRAF site, the base class is GirafController (abstract) and the only two special methods are \emph{index} and \emph{fallback}. The index method is used as a default action if the controller is invoked without any specific request. The fallback method is used when an unknown action (non-existing method) is requested.
All methods that are controller actions must accept a single, optional, parameter, an associative array of parameters. The indices in the array are created by the index.php script before the controller is invoked. Depending on the parameters passed during the page request, the indices "controller", "action" and a number of "paramX" indices (where X is the zero-indexed number of the parameter) will be created with corresponding content from the page request.
Finally, GirafController implements a view method that parses a single view file from the document root's \emph{/views} folder. The view method optionally takes an associative array of values to be made available to the called view. This is done by extracting the values and storing them in variables with the same name as that value's key.The value 14 in the index userId would thus be available in the view as the variable userId.

\subsection{Usage examples}
This sub section briefly describes the three primary envisioned usage scenarios of GirafController: a core controller, a minimal-output controller and a Giraf application sub controller.

\subsubsection*{A normal controller}
The main controller makes use of all of the base functionality of GirafController and thus proves a solid example of core usage. \todo{Should we just keep code listings elsewhere, the appendix, maybe? - Joe}

\lstinputlisting[language=PHP]{tex/implementation/controller_example_main.php}

Notice how the controller \emph{always} defers control to the fallback method that ignores any extra parameters and simply shows the default page. A complete page for display is typically comprised of a header (that contains starting tags for html and body, doctype and any global javascript and css file links), a footer (that closes tags from the header and may contain global footer content) and main content. Note in the code that three views are loaded by main: header.php, main\_stub.php and footer.php. Both header and footer are also used by the Login controller and should be used by any GirafController that displays a full page to the user (future examples could include account, user and group administration pages).

\subsubsection*{A JSON controller}
\lstinputlisting[language=PHP]{tex/implementation/controller_example_child.php}

The Child controller demonstrates how an already generated web page can request new data in the background in order to reduce page loads, but also introduce a more dynamic page impression. In its current implementation this kind of controller exclusively outputs JSON that can be readily consumed by the javascript already loaded by the client. It is debatable whether the direct output of JSON from the controller (and not an actual view) goes against the MVC pattern.
The JSON controller type is not a subclass in an of itself (yet), but is intended to pass simple data structures back to the client, enabling both AJAX from the browser but also opens the door for an external API that can be utilised by other sites for greater extensions of the framework.

\subsubsection*{A sub controller}
\label{controller_sub}
\lstinputlisting[language=PHP]{tex/implementation/controller_example_contactbook.php}

The Contactbook controller class is currently the only example of a sub controller and is thus partly intended as a practical example of how new GIRAF-compliant applications can offer customised administrative functions for users beyond a simple control over the settings of the application on a device.
Of greatest interest (and the feature that most notably makes the controller a "sub" type) is the lack of header and footer views, or their equivalents. These controllers are designed to be injected into HTML that is already loaded with the necessary data to run in a browser. Thanks to the flexibility of the DOM it is possible to add stylesheet and javascript files after the document was originally loaded, in principle making it possible to use the entire GIRAF site without ever replacing the header and footer sections.
Of smaller note is the action  \_list. In PHP the word "list" is reserved and cannot be used for any definitions. The name was needed for an action, however. A workaround is to utilise the fallback method to check if the requested action is "list". If it is, execution is passed to the \_list method.

\subsection{Implemented controllers}
Following is a quick list of the controllers currently implemented in GIRAFAdmin. They are divided into the aforementioned three groups: main, sub and JSON controllers.

\subsubsection*{Main}
GIRAFAdmin has two main controllers in the current version for direct user interaction, Main and Login, as well as a single controller meant for sub controller interaction - Module.
\begin{description}
    \item[Login] is for user authentication, registration and aid in case the user has forgotten their password.
    \item[Main] is used as a primary overlay and access point to administration of all children, devices and applications.
    \item[Module] is used as a proxy for all controllers associated with applications that need to be managed through GIRAFAdmin. Requests are passed almost transparently through to the requested sub controller, but basic authentication measures can ensure that unauthourised access is halted.
\end{description}

\subsubsection*{Sub}
As mentioned in \vref{controller_sub}, only one sub controller is currently implemented - Contactbook. It exposes all the functionality that a user should directly be able to access as defined in the original design (message listing, creation, replies and such).

\subsubsection*{JSON}
The GIRAFAdmin view \emph{main\_stub} makes significant use of AJAX to request new data after a page has loaded. In order to simplify request of the data, and reduce bandwidth usage and processing requirements, only the most necessary data is transferred. The current four JSON controllers (App, Child, Device and Group( are all variants of a basic data retrieval mechanism - their names directly reflect what type of information they output. App outputs information about installed applications, Child about children, and so on. They can list data associated with a single entity (children to a user or apps on a device, for example) and return it as a JSON-encoded string that can be consumed by JavaScript.

\section{Conclusion}
In conclusion, the current implementation of GIRAFAdmin has an open and flexible approach to the MVC pattern. The way page requests are parsed into parameters makes implementing new controllers a simple task of creating a new subclass in the correct directory. Furthermore, several methods offers simple ways of controlling default behaviour, unexpected input and view loading.