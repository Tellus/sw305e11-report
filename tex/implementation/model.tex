\section{Model}
\label{model}
This section describes how the model was implemented into GIRAFAdmin's MVC architecture. In particular implementing a combined Active Record/Factory pattern and automating the model's self-defining properties are described.

\subsection{The GirafRecord class}
GirafRecord is designed as a combination of the Active Record and Factory patterns. Subclasses of GirafRecord need only specify their source table and associations within overridden methods getSourceTable, getPrimaryKey and setAssociations. Using this data, GirafRecord determines the appropriate class to instantiate upon request through the getInstance method (which is proxied automatically into methods in the format "getClassName" - for example getGirafChild for the GirafChild class) and dynamically creates the members necessary to properly represent the underlying database table. Thus changing the value of a field (member) for a row (object) is only a question of changing the value of that object's corresponding member (user $\rightarrow$ statusKey in the case of GirafUser, for example). Changes are not written back to the database until the commit method is call on the object.

The class diagram showed in appendix \ref{diagramAppendix} is made to show the relation between the GirafRecord class and some of the other classes used in the Giraf system.\todo{What is the use of this? We can depict the inheritance diagram, but what's with the "other classes" bit?}

\subsection{Dynamic shaping}
Thanks for the dynamic typing properties of PHP, object of classes can be modified during run-time. PHP also has several so-called "magic methods" that can increase the flexibility of classes. Three of these, two for properties and one for methods, was applied to dynamically shape objects to the tables they were representing.

\subsubsection*{Properties}
PHP defines the class methods \_\_get and \_\_set. They are called whenever a non-existing member is requested. For GirafRecord, this means that although table columns are not defined as members in the class, they are available at run-time. \_\_get and \_\_set perform lookups in a private array of key-value pairs that match the table's structure, and registers any changes to the data.
Both row structure and data are returned as an associative array through PHP's MySQL functionality, and distilled into the internal data array where \_\_get and \_\_set and work with it.

\subsubsection*{Methods}
The methods \_\_call and \_\_callStatic are defined with similar usages as \_\_get and \_\_set, only with object and class methods, respectively. GirafRecord overrides \_\_callStatic to offer an instance-retrieval method that matches a subclass. This is merely a proxy for GirafRecord's getInstance method, but makes for slightly more readable code. For example, the class GirafUser automatically defines getGirafUser, GirafGroup defines getGirafGroup and so on.

\subsection{CRUD}
GirafRecord only defines functionality for creating, reading and updating records in the current implementation. Due to the complications of retaining key integrity across table associations, row deletion was never implemented. Although the InnoDB engine (used in all the Giraf database tables) supports this integrity, relying on that implementation would rule out the use of any other database system or even MySQL engine, severely reducing the portability of the system.

\subsection*{Create}
Creating a new record simply involves creating a new instance of the desired record, settings its values and calling the commit method. Each GirafRecord maintains a private array of which fields have been changed since initialisation. During creation of a new record only these values are set, any unset values are set to null.

\subsection*{Read}
Retrieving an existing record is achieved by calling the getInstance method (or its subclass equivalent) and passing the primary key value of the desired row to it. If it exists, an object is prepared, ready for consumption and false (a typical PHP failure value for function calls) if the record does not exist.

\subsection*{Update}
Updating is performed first by reading (getInstance) an object, changing values (as with creation) and finally committing. Like the create flow, GirafRecord registers changed fields and only updates them.

\subsection{The MySQL database}
Early on in the project, the previous grops' GirafPlace database (responsible for registering GIRAF applications and making them available for download to devices) was merged with the new emerging GIRAFAdmin database in order to create a single, centralised system. It contains tables with data about administratiors, applications, children, groups, devices and more.
As described in subsection \vref{design_tech_model}, the GirafRecord base class follows the Active Record architectural pattern. Thus, in order to retrieve rows from the table \emph{devices} the corresponding model class GirafDevice is instantiated through the static getGirafDevice method.

\subsubsection{Database relations}
MySQL supports a number of database engines, different implementations that offer varying levels of performance and added features. Among them, only one supports explicitly defining associations/relations between tables and only for the purposes of concurrency and bloat reduction. This necessitates a different approach to defining strong associations between tables. In the current implementation, it is achieved by using static methods overridden in each subclass of GirafRecord or residing in the base class.
addAssociation connects two GirafRecord subclasses within the context of an association table - that is, a table that only contains a primary key (denoting a single relationship), a left (or parent) key to one half of the association and a right (or child) key to the other half. The designed associations can all be viewed in appendix \vref{fig:database_relations}.

As a convention (and good design), every single table in the database contains a primary key that can be used to uniquely identify a row within the table. In general it is referred to as the table name in singular appended with "Id" (for example, the table \emph{devices} has the primary key in the field \emph{deviceId}. This is the key referenced either as a left or right part of an assocation. Note the convention of calling the value an "id" when referenced locally (within a single table) and as "key" when referenced remotely (also sometimes referred to as a foreign key).

Any one-to-one or one-to-many associations are implemented using only the two tables involved. In the case of users, for example, any one user can only have one active status (online, offline, away) at any given point. That status, however, may be applicable to several different users at once. Thus "statusKey" is defined in the users table to reference which status is currently active, while the status itself has no relation in the other direction. This also demonstrates why describing an association as a parent-child association (downwards) communicates the direction and nature of the association, while "left-right" is meant for uni-directional associations.

Many-to-many associations must be implemented with an extra table; the aforementioned association table. In the case of groups, for example, a group has a number of users attached to it. Conversely a user may be a member in any number of groups. Defining a new table field for each (possible) association causes unnecessary and indeterminable bloat (four association fields are unnecessary for a user in a single gorup, while it does not suffice for a user in eight). An alternative is to register all associations in a single field, delimited by a special character (commas, for example). This approach requires more logic to be implemented in the model and uses less of the power of relational database systems. Using assocation tables are the clear choice.