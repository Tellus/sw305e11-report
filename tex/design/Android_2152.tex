\section{GIRAF synchronization framework}
The original project proposal was about creating an administrative PC tool which should be able to synchronize data for a GIRAF tablet device. This could be one device at the time, or many devices through a centralized management system. In the beginning of the design process this general idea was used and developed upon. From this, specifics to a solution was made, including a detailed design process, additions to the existing framework an some proof-of-concept code. After the 2 first interviews with Birken, this part of the project was discontinued, because the contact book application was a more pressing feature. Although discontinued, some of the code parts are fully functional; and it is still an important part of some of the initial project work that was made. Furthermore, the source code and designs made here, could be carried on as material for further development. 

The general idea included that the software should feature user profile and application settings synchronization. Moreover, the existing GIRAF-android client has functionality to install and view available applications. In milestone 1.0 of the client software, this feature should be merged with the synchronization application, making it possible to control available applications through Access Control Lists (ACL). 


\section{Protocol design v0.1 draft}
This design has not been fully implemented, only some of the design parts have been written in code. Also contains milestone perspectives. Protocol functionality is described in detail and can be used a direction indicator for further development.   

\subsection{Handshake}
The first message sent from the client is a handshake. The handshake is very simple, since it only expects a string containing "HELLO", immediately followed by a version string.

\subsection{Version} 
The version string consists of 3 parts of versioning numbers, which indicates the significance of changes made to the software. First number is major release, next is minor release, and the last number is the build number. The version numbers are separated in the string by a dot (".") character, example for a version string would look this: "1.0.1". If the server encounters a client with a newer version than its own, the server will at the moment refuse the client to connect. However, theoretically, the server could still offer functionality that has not been changed in the new version, or which does not have updated dependencies. In protocol milestone 1.0 it is not planned; however, such functionality could still be implemented by sending a short version string together with the message making it possible for the server deciding whether a particular function is still supported, even though the client version is newer. However, such scenario is unlikely to happen. 
If a valid version is detected, the server answers "OK" and command messages can now be sent from the client.

\subsection{Ident}
Ident is performed after a successful handshake and version check - and the client have received an "OK" from the server - the client will create an MD5 hash of its WiFi (Wireless Fidelity) unique network address, also called a Media Access Control address (MAC). MAC addresses are generally used to identify network equipment of any kind using any implementation of the IEEE 802 standard\cite{IEEE}, and are frequently used to control network equipment through an ACL \cite{cisco}. The purpose of the ident is to create a simple, yet effective ACL which provides a filter on which application settings (and, in protocol milestone 1.0 this will also include installable applications as well) are accessible to the client. MD5 hashes are not collision-safe\cite{ACCESSDATA}, but any collisions would be highly unlikely, due to the source, which in this case is MAC-48 address. 
The ident is sent to the server after the client receives the "OK" signal. After an ident is successfully received by the server, the server sends an "OK" signal to the client, indicating that it is ready to receive further instructions. 

\subsection{Timestamp}
After a successful ident, the client sends a timestamp string of the current time formatted as unix time. The server then calculates the difference between its own time and the client's time, taking into calculation that the server and client might be in different time zones. If the time difference is greater than +/- 12 hours (The max possible difference when calculating time), the server returns an error message "TIME\_NOT\_CONFIGURED" to the client, and ends communication. Otherwise, the server answers "OK". 
Next, the client sends it's last update time to the server. If no update time exists, the server receives the "FIRST\_UPDATE" message from client.

\subsection{User profile transfer}
The client initiates the user profile transfer  by sending the "USER\_PROFILE" command message. If the server receives the message, an "OK" is returned to the client. The client sends any timestamps newer than the last update time. If an update from the server is newer than the last update time, and the client has a conflicting update, the server always wins. All data with a newer time stamp is transmitted back to the client. When all data has been sent, the server sends the "DONE" signal. 

\subsection{Application transfer}
Application transfer is initiated by the client sending the "APP\_TRANSFER" command message to the server and the server responds with "OK". The client sends a list of installed GIRAF applications together with the application version string. If any updates are available, these will be installed first. Any applications marked for installation will be sent to the server after updates completes.   

\section{Settings transfer}
Initiated by the client, by sending the "SETTINGS\_TRANSFER" message to the server. The client locates all rows in the local SQLite database with a newer timestamp than the last update time and transfers these rows the server. The server evaluates each row against the centralized database. If a newer entry already exists in fore mentioned database, the data is dropped - in other words, server always wins when data collision occur. This choice makes sense, since the device administrators pushing updates should be ensured that new settings reaches the target device; An example could be a newly installed application - which haven't been updated - containing database information, where the user only has read-only access. This ensures that device administrators still retain the possibility to update the values.
When all data has been successfully sent, the client sends the "OK" message - next, the server sends back any rows that is newer than the last update time. Although not planned in milestone 1.0, the ability to implement group settings should be kept in mind if such functionality is needed in the future. 


