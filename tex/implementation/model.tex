\section{Model}
\label{model}

In this section, the model component of the system, and how the model uses \textit{datacontainer} classes to access the data listed in the database. Furthermore the section will include a description of the relations within the database and a description of the class, \textit{GirafRecord} and some of its subclasses.

\subsection{The \textit{GirafRecord} class}
The \textit{GirafRecord} class is the base class of all Giraf classes used for data containing. The \textit{GirafRecord} class is an abstract class, which means that the objects of the class cannot be instantiated, whereas the subclasses inherit attributes and operations from the \textit{GirafRecord} class. 
%The \textit{GirafRecord} class and its subclasses can be seen in figure \ref{fig:diagram} in appendix \ref{diagramAppendix}.
The class diagram showed in appendix \ref{diagramAppendix} is made to show the relation between the GirafRecord class and some of the other classes used in the Giraf system.
%All included classes, besides the GirafRecord class itself, are subclasses of the GirafRecord class. This means that the subclasses inherit all the functions and attributes from the GirafRecord class.
%The subclasses of the GirafRecord class can override some function and attributes of the main class, and other functions and attributes has to be overridden by the subclasses, these functions and attributes are the ones which is shown in all included classes in appendix \ref{diagramAppendix}.
%An example of this, is the attribute 'RETURN\_PRIMARYKEY' and the function 'getPrimaryKey()'.

\subsection{The MySQL database}
Early on in the project, the previous grops' GirafPlace database (responsible for registering GIRAF applications and making them available for download to devices) was merged with the new emerging GIRAFAdmin database in order to create a single, centralised system. It contains tables with data about administratiors, applications, children, groups, devices and more.
%The database uses the Giraf system, called \textit{GirafPlace}. \textit{GirafPlace} contains some different tables. These tables contain data about administratiors, applications, children, groups, devices and more.
As described in subsection \vref{design_tech_model}, the GirafRecord base class follows the Active Record architectural pattern. Thus, in order to retrieve rows from the table \emph{devices} the corresponding model class GirafDevice is instantiated through the static getGirafDevice method.
%The model gets access to the data in the databasetables by calling methods in one of the datacontainer classes, for example, if the database table \textit{devices} has to be accessed, the datacontainer class \textit{GirafDevice} is used.

\subsubsection{Database relations}
MySQL supports a number of database engines, different implementations that offer varying levels of performance and added features. Among them, only one supports explicitly defining associations/relations between tables and only for the purposes of concurrency and bloat reduction. This necessitates a different approach to defining strong associations between tables. In the current implementation, it is achieved by using static methods GirafRecord related to creating and following associations
addAssociation connects two GirafRecord subclasses within the context of an association table - that is, a table that only contains a primary key (denoting a single relationship), a left (or parent) key to one half of the association and a right (or child) key to the other half. The designed associations can all be viewed in \vref{fig:database_relations}.
%The database contains some tables and some relations between these tabels. The tables and the relations between the tables can be seen in figure \ref{fig:database_relations} in appendix \ref{diagramAppendix}.
As a convention (and good design), every single table in the database contains a primary key that can be used to uniquely identify a row within the table. In general it is referred to as the table name in singular appended with "Id" (for example, the table \emph{devices} has the primary key in the field \emph{deviceId}. This is the key referenced either as a left or right part of an assocation. Note the convention of calling the value an "id" when referenced locally (within a single table) and as "key" when referenced remotely (also sometimes referred to as a foreign key).
%Each of the tables in the database contains an attribute \emph{Id}. This attribute is used to indicate the relations of the table. Two tables' relations is verified by an id and a key, one of the tables contains the id, and the other table contains the key, as shown in figure \ref{fig:database_relations}, where the arrows indicate which table contains the key and which key contains the id. The table pointed to by the tip of the arrow is the table containing the key, and the table from which the arrow points is the table containing the id. 
%For example, the attribute  \textit{statusKey} in table \textit{users} is related to the attribute \textit{statusId} in the table \textit{userStatus}.
Any one-to-one or one-to-many associations are implemented using only the two tables involved. In the case of users, for example, any one user can only have one active status (online, offline, away) at any given point. That status, however, may be applicable to several different users at once. Thus "statusKey" is defined in the users table to reference which status is currently active, while the status itself has no relation in the other direction. This also demonstrates why describing an association as a parent-child association (downwards) communicates the direction and nature of the association, while "left-right" is meant for uni-directional associations.
Many-to-many associations must be implemented with an extra table; the aforementioned association table. In the case of groups, for example, a group has a number of users attached to it. Conversely a user may be a member in any number of groups. Defining a new table field for each (possible) association causes unnecessary and indeterminable bloat (four association fields are unnecessary for a user in a single gorup, while it does not suffice for a user in eight). An alternative is to register all associations in a single field, delimited by a special character (commas, for example). This approach requires more logic to be implemented in the model and uses less of the power of relational database systems. Using assocation tables are the clear choice.

\subsection{GirafRecord}
GirafRecord is designed as a combination of the Active Record and Factory patterns. Subclasses of GirafRecord need only specify their source table and associations within overridden methods getSourceTable, getPrimaryKey and setAssociations. Using this data, GirafRecord determines the appropriate class to instantiate upon request through the getInstance method (which is proxied automatically into methods in the format "getClassName" - for example getGirafChild for the GirafChild class) and dynamically creates the members necessary to properly represent the underlying database table. Thus changing the value of a field (member) for a row (object) is only a question of changing the value of that object's corresponding member (user->statusKey in the case of GirafUser, for example). Changes are not written back to the database until the commit method is call on the object.
%The model gets access to the data in the database tables by calling methods in one of the datacontainer classes, for example, if the database table \textit{devices} has to be accessed, the datacontainer class \textit{GirafDevice} is used. \todo{may have to include some code examples, but I cannot chose which one to include}
GirafRecord stores a global record of all associations registered at run-time and uses this data when a subclass requests associated records from a particular table.