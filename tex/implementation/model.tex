\section{Model}
\label{model}
This section describes how the model was implemented into GIRAFAdmin's MVC architecture. In particular implementing a combined Active Record/Factory pattern and automating the model's self-defining properties are described.

\subsection{The GirafRecord class}
GirafRecord is designed as a combination of the Active Record and Factory patterns. Subclasses of GirafRecord need only specify their source table and associations within overridden methods getSourceTable, getPrimaryKey and setAssociations. Using this data, GirafRecord determines the appropriate class to instantiate upon request through the getInstance method (which is proxied automatically into methods in the format "getClassName" - for example getGirafChild for the GirafChild class) and dynamically creates the members necessary to properly represent the underlying database table. Thus changing the value of a field (member) for a row (object) is only a question of changing the value of that object's corresponding member (user $\rightarrow$ statusKey in the case of GirafUser, for example). Changes are not written back to the database until the commit method is call on the object.

GirafRecord stores a global record of all associations registered at run-time and uses this data when a subclass requests associated records from a particular table.

The class diagram showed in appendix \ref{diagramAppendix} is made to show the relation between the GirafRecord class and some of the other classes used in the Giraf system.\todo{What is the use of this? We can depict the inheritance diagram, but what's with the "other classes" bit?}

\subsection{The MySQL database}
Early on in the project, the previous grops' GirafPlace database (responsible for registering GIRAF applications and making them available for download to devices) was merged with the new emerging GIRAFAdmin database in order to create a single, centralised system. It contains tables with data about administratiors, applications, children, groups, devices and more.
As described in subsection \vref{design_tech_model}, the GirafRecord base class follows the Active Record architectural pattern. Thus, in order to retrieve rows from the table \emph{devices} the corresponding model class GirafDevice is instantiated through the static getGirafDevice method.

\subsubsection{Database relations}
MySQL supports a number of database engines, different implementations that offer varying levels of performance and added features. Among them, only one supports explicitly defining associations/relations between tables and only for the purposes of concurrency and bloat reduction. This necessitates a different approach to defining strong associations between tables. In the current implementation, it is achieved by using static methods GirafRecord related to creating and following associations
addAssociation connects two GirafRecord subclasses within the context of an association table - that is, a table that only contains a primary key (denoting a single relationship), a left (or parent) key to one half of the association and a right (or child) key to the other half. The designed associations can all be viewed in \vref{fig:database_relations}.
As a convention (and good design), every single table in the database contains a primary key that can be used to uniquely identify a row within the table. In general it is referred to as the table name in singular appended with "Id" (for example, the table \emph{devices} has the primary key in the field \emph{deviceId}. This is the key referenced either as a left or right part of an assocation. Note the convention of calling the value an "id" when referenced locally (within a single table) and as "key" when referenced remotely (also sometimes referred to as a foreign key).
Any one-to-one or one-to-many associations are implemented using only the two tables involved. In the case of users, for example, any one user can only have one active status (online, offline, away) at any given point. That status, however, may be applicable to several different users at once. Thus "statusKey" is defined in the users table to reference which status is currently active, while the status itself has no relation in the other direction. This also demonstrates why describing an association as a parent-child association (downwards) communicates the direction and nature of the association, while "left-right" is meant for uni-directional associations.
Many-to-many associations must be implemented with an extra table; the aforementioned association table. In the case of groups, for example, a group has a number of users attached to it. Conversely a user may be a member in any number of groups. Defining a new table field for each (possible) association causes unnecessary and indeterminable bloat (four association fields are unnecessary for a user in a single gorup, while it does not suffice for a user in eight). An alternative is to register all associations in a single field, delimited by a special character (commas, for example). This approach requires more logic to be implemented in the model and uses less of the power of relational database systems. Using assocation tables are the clear choice.