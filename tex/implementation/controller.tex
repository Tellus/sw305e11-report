\section{Controller}
\label{controller}
This section will discuss the controller layer of the Giraf site, in particular the \emph{GirafController} class as well as the interplay of JSON and the incomplete views that are output by certain controller actions. The discussion will center on the philosophy and inspirations behind the technical design of the controller, finally leading to the implementation that was completed as part of the this project period. The section will end with an overview and an example usage of the three base scenarios envisioned for \emph{GirafController}.

\subsection{Technology}
The method of input/output is highly inspired by several existing web-based MVC frameworks, most notably Ruby on Rails (implemented in the Ruby programming language) and CodeIgniter (made in PHP) - the specifics will be discussed in subsection \vref{controller_design}.

\subsection{Base concept}
Ensuring that the security concerns voice by Birken (see appendix \vref{first_interview_birken}, 47:40 and appendix \vref{sec_interview_birken} 54:00) would be addressed was a key factor when considering how to implement the input/output flow through the website.

\subsubsection*{Security concerns}
The assets that need to be secure are universally defined as the user-generated content associated with users and children. In the specific context of this project, this is their personal details, contact book messages and the attached images. There are two steps to securing the data. First of all, data should be stored in a database with strict access rules. In MySQL it is possible to restrict access to the GIRAF database down to a single user and source address. Specifying that only the local system may access the database effectively eliminates direct intrusion into that part of the system. However, images and binary data in general are a point of contention in regards to storage. While some argue it improves security and reduces overhead otherwise connected to file system accessing, others yet take the point that storing and retrieving large blobs of data risks locking up the database for further requests while transfers are in progress. Three approaches to securing such data are described as follows:

\begin{description}
    \item[Temporary files] One approach involves copying inaccessible files to accessible locations on the web server with randomly generated names. Once the images have been loaded by the client they can be safely removed (images are transferred during page load and not used for the remainder of the page display). Disk usage can further be reduced by using linking features specific to operating systems (Linux systems' ln command or the junction points of Windows' junction points), eliminating redundant versions of identical files. This approach presents the same basic vulnerabilities as the current implementation (files are externally accessible), but to a much lesser degree (only files currently in use are exposed). However, this comes at the cost of file maintenance. Server-side scripts will need to remove the files when they are no longer required.
    \item[Direct image output] Another approach is to store files in a location that is inaccessible to external sources, and output the content of the files through the MVC framework directly to the client. The difference between transmitting a page of HTML or binary image data is discernible only by the actual data and the MIME type reported by the server during transmission. Using this approach will make it possible to access all resources through a single access point (for example, a controller that receives resource identifiers and outputs their contents if the request can be authorised), giving strict control over access. An added benefit is that the actual resource data can be stored in any location that is reachable by the server-side PHP code, be it file system, within databases or on remote servers. The only immediate downside is the added overhead of the script that needs to output the data (in contrast to regular file accessibility, in which only the web server is active in delivering data).
    \item[Authentication schemes] A third approach is to use one of the many authentication protocols supported by HTTP to restrict access to externally accessible resources. While this vastly simplifies the storage of resources on the server (to the level of the current implementation), it bears the need to implement support for the authentication protocol in the web pages and may require additional software on server and/or client.
\end{description}

Each approach has merit depending on the context, although the final level of security increases roughly from the first approach to the last. The second approach is both simple to implement (all of the required functionality exists in PHP) and exhibits a level of access control that is only limited by the robustness of the code. There are still types of attack that the code is vulnerable to:

\paragraph*{Injection attacks}
Injection attacks involve a malicious user sending unexpected input values. Typically they will anticipate an SQL selection query in the style of ``SELECT data FROM table WHERE username='some\_name''', where \emph{some\_name} is replaced with the user's input. If the input is not properly sanitised, a malicious user could send an input like "' OR TRUE=TRUE" OR '". Pay close attention to the additional quotes that will effectively end one SQL condition, add a tautology and properly end the condition, resulting in "username='' OR TRUE=TRUE OR ''". The user has \emph{injected} new executable code into the query, an unintentional an dangerous security hole. The solution is simple to implement, though difficult to perform comprehensively. Any input strings from the user should be sanitised (made safe) by escaping (prepending backslashes to) any characters that bear special meaning in SQL contexts. Quotes in particular, should be escaped to avoid execution to run outside its intended area.

The seeds of the resource access restrictions already exist in the framework. The site is intended to be used by clients exclusively through the execution of the base index.php script as well as access to two key directories: css (for stylesheets) and js (for javascript files) - neither contain confidential information, only resources necessary for proper rendition of web pages. A default web server configuration will typically allow access to all resources, requiring additional setup when installing the software on a new server. See the appendix \vref{appendix_server_conf} for an example configuration used by the project group's installation. It restricts access to all other resources than the one file and two directories named, redirecting all unrecognized requests directly to the index.php file. This adds the benefit of making a cleaner, more easily read URL format (http://www.giraf.dk/contactbook/list/3 as opposed to http://www.giraf.dk/contactbook.php?action=list\&userid=3).

\subsubsection*{File structure}
All controllers reside in the \emph{/controllers} subdirectory of the web site document root. Furthermore, given the convention of placing GIRAF application-specific data in \emph{/apps} subdirectories, any administration controllers offered by uploaded GIRAF applications are stored in such a directory.

It is the intention that all controllers callable directly by the user reside in that root, while all GIRAF application controllers (referenced as \emph{sub-controllers}) must be accessed by primary controllers. A special controller for this purpose (the \emph{Module} controller) exists to allow restricted access to them externally - this is more a user-friendly filtration than a security measure. \emph{Module} has the capability to ensure that the child/device/app configuration requested is valid, reducing the risk of corrupted or bad page reads.

\subsection{Controller design}
\label{controller_design}
As mentioned the Giraf MVC design is highly inspired by that of other web-based MVC frameworks, in which each controller is represented by a subclass of a base controller class. Barring a few special name cases, each public method of the class is considered an action that can be invoked directly by a client.
In the case of the GIRAF site, the base class is \emph{GirafController} (an abstract class) and the only two special methods are \emph{index} and \emph{fallback}. \emph{index} is used as a default action if the controller is invoked without any specific request. \emph{fallback} is used when an unknown action (non-existing method) is requested.
Finally, \emph{GirafController} implements a method, called \emph{view}, that parses a single view file from the document root's \emph{/views} folder. \emph{view} optionally takes an associative array of values to be made available to the called view. This is done by extracting the values and storing them in variables with the same name as that value's key. The value 14 in the array index ``userId'' would thus be available in the view as the variable ``userId''.

\subsection{Implementation}
As the primary access point to GIRAFAdmin for users, controllers are exposed simply by accessing the web server with an appropriate URL. With a proper server setup as described earlier, all unrecognised server requests go through index.php. The file performs the following actions in order before any output is sent to the client browser (in fact, all output is suppressed from the URL parsing until controller invocation has been resolved):
\begin{enumerate}
    \item \textbf{Authorisation} If no user has been logged in (that is, if no active PHP session can be found), the user is forced into the Login controller if it was not specifically requested. This makes it impossible to access the rest of the GIRAFAdmin site without being registered and authorised.
    \item \textbf{URL parsing} The requested URL (for example ``/login/register'') is parsed into an array of parameters more easily digested by later code. The first element after the document root is put into the index ``controller'', the second into the index ``action'' and all following elements in ``paramX'' indices, where \textbf{X} is the zero-based number of the parameter.
    \item \textbf{Controller invocation} Assuming a controller was requested (if not, \emph{Main} is set as a default), the subdirectory \emph{/controllers} is searched for a file with the same name as the requested controller (in a case-insensitive manner). If it is found, that single found is included into variable scope. If not, all files in the directory are included into variable scope and all newly-defined classes are searched (this is a more resource-demanding process and therefore used only as a last effort). A new object of the class is finally created, or if the controller was not found an error is thrown.
    \item \textbf{Action is called} If no action was defined, the controller's index method is invoked. Otherwise, the controller object is polled for the requested action. If it exists, the corresponding method is invoked with the URL path (now in array form) as parameter. If not, the fallback method is invoked instead.
    \item \textbf{Invocation returns control} The controller passes control back to the main thread and the output buffer is flushed, finally sending output to the browser.
\end{enumerate}

\subsection{Usage examples}
This sub section briefly describes the three primary envisioned usage scenarios of GirafController: a core controller, a minimal-output controller and a GIRAF application sub controller.

\subsubsection*{A normal controller}
The controller \emph{Main} makes use of all of the base functionality of \emph{GirafController} and thus proves a solid example of core usage.

\lstinputlisting[language=PHP]{tex/implementation/controller_example_main.php}

Notice how the controller \textbf{always} defers control to \emph{fallback} that ignores any extra parameters and simply shows the default page. A complete page for display is typically comprised of a header (that contains starting tags for html and body tags, HTML doctype and any global JavaScript and CSS file links), a footer (that closes tags from the header and may contain global footer content) and main content. Note in the code that three views are loaded by \emph{Main}: header.php, main\_stub.php and footer.php. Both header and footer are also used by the controller \emph{Login} and should be used by any \emph{GirafController} that displays a full page to the user (future examples could include account, user and group administration pages).

\subsubsection*{A JSON controller}
\lstinputlisting[language=PHP]{tex/implementation/controller_example_child.php}

The controller \emph{Child} demonstrates how an already generated web page can request new data in the background in order to reduce page loads, but also introduce a more dynamic page impression. In its current implementation this kind of controller exclusively outputs JSON-encoded data that can be readily consumed by the JavaScript already loaded by the client. It is debatable whether the direct output of JSON-encoded data from the controller (and not an actual view) goes against the MVC pattern.
The JSON controller type is not a subclass in itself (yet), but is intended to pass simple data structures back to the client, enabling both AJAX from the browser but also enables an external API that can be utilized by other sites for greater utility of the framework.

\subsubsection*{A sub controller}
\label{controller_sub}
\lstinputlisting[language=PHP]{tex/implementation/controller_example_contactbook.php}

The controller \emph{Contactbook} is currently the only example of a sub controller and is thus partly intended as a practical example of how new GIRAF-compliant applications can offer customised administrative functions for users beyond a simple control over the settings of the application on a device.
Of greatest interest (and the feature that most notably makes the controller a ``sub'' type) is the lack of header and footer views, or their equivalents. These controllers are designed to be injected into HTML that is already loaded with the necessary data to run in a browser. Thanks to the flexibility of the DOM it is possible to add stylesheet and javascript files after the document was originally loaded, in principle making it possible to traverse the entire GIRAF site without ever replacing the header and footer sections.
Of smaller note is the action  \emph{\_list}. In PHP the word ``list'' is reserved and cannot be used for any definitions. However, the name was a prime candidate for the name of an action. A workaround is to utilise \emph{fallback} to check if the requested action is ``list''. If it is, execution is passed to \emph{\_list} instead.

\subsection{Implemented controllers}
Following is a quick list of the controllers currently implemented in GIRAFAdmin. They are divided into the aforementioned three groups: main, sub and JSON controllers.

\subsubsection*{Main}
GIRAFAdmin has two main controllers in the current version for direct user interaction, \emph{Main} and \emph{Login}, as well as a single controller meant for sub controller interaction - \emph{Module}.
\begin{description}
    \item[Login] is for user authentication, registration and aid in case the user has forgotten their password.
    \item[Main] is used as a primary overlay and access point to administration of all children, devices and applications.
    \item[Module] is used as a proxy for all controllers associated with applications that need to be managed through GIRAFAdmin. Requests are passed almost transparently through to the requested sub controller, but basic authentication measures can ensure that unauthourised access is halted.
\end{description}

\subsubsection*{Sub}
As mentioned in subsection \vref{controller_sub}, only one sub controller is currently implemented - \emph{Contactbook}. It exposes all the functionality that a user should directly be able to access as defined in the original design (message listing, creation, replies and such).

\subsubsection*{JSON}
The GIRAFAdmin view \emph{main\_stub} makes significant use of AJAX to request new data after a page has loaded. In order to simplify request of the data, and reduce bandwidth usage and processing requirements, only the most necessary data is transferred. The current four JSON controllers (\emph{App}, \emph{Child}, \emph{Device} and \emph{Group}) are all variants of a basic data retrieval mechanism - their names directly reflect what type of information they output. \emph{App} outputs information about installed applications, \emph{Child} about children, and so on. They can list data associated with a single entity (children to a user or apps on a device, for example) and return it as a JSON-encoded string that can be consumed by JavaScript.

\section{Conclusion}
In conclusion, the current implementation of GIRAFAdmin has an open and flexible approach to the MVC pattern. The way page requests are parsed into parameters makes implementing new controllers a simple task of creating a new subclass in the correct directory. Furthermore, several methods offers simple ways of controlling default behavior, unexpected input and view loading.
